return(list(graph = H_plot, Hdata = data, removed = removed_individuals))
}
########################## End FUnction ########################################
# Calculating Heritability from all data sets
# # Both years avaraged, heritabilities
# stats_avg_310_alk <- refine_heritability(Residual_data_avg_outliars_rm_314x310, geno_matrix, trait = "Alkaloids_Res")
# H_avg_310_alk <- stats_avg_310_alk$H[1]
#
# stats_avg_312_alk <- refine_heritability(Residual_data_avg_outliars_rm_314x312, geno_matrix, trait = "Alkaloids_Res")
# H_avg_312_alk <- stats_avg_312_alk$H[1]
#
# stats_avg_star_alk <- refine_heritability(Residual_data_avg_outliars_rm, geno_matrix, trait = "Alkaloids_Res")
# H_avg_star_alk <- stats_avg_star_alk$H[1]
#
# stats_avg_310_ct <- refine_heritability(Residual_data_avg_outliars_rm_314x310, geno_matrix, trait = "Delta_CT_adj_Res")
# H_avg_310_ct <- stats_avg_310_ct$H[1]
#
# stats_avg_312_ct <- refine_heritability(Residual_data_avg_outliars_rm_314x312, geno_matrix, trait = "Delta_CT_adj_Res")
# H_avg_312_ct <- stats_avg_312_ct$H[1]
#
# stats_avg_star_ct <- refine_heritability(Residual_data_avg_outliars_rm, geno_matrix, trait = "Delta_CT_adj_Res")
# H_avg_star_ct <- stats_avg_star_ct$H[1]
#
#
# # Just the 2023 heritabilities
# stats_2023_310_alk <- refine_heritability(Residual_Data_23_outliars_rm_314x310, geno_matrix, trait = "Alkaloids_Res")
# H_2023_310_alk <- stats_2023_310_alk$H[1]
#
# stats_2023_312_alk <- refine_heritability(Residual_Data_23_outliars_rm_314x312, geno_matrix, trait = "Alkaloids_Res")
# H_2023_312_alk <- stats_2023_312_alk$H[1]
#
# stats_2023_star_alk <- refine_heritability(Residual_Data_23_outliars_rm, geno_matrix, trait = "Alkaloids_Res")
# H_2023_star_alk <- stats_2023_star_alk$H[1]
#
# stats_2023_310_ct <- refine_heritability(Residual_Data_23_outliars_rm_314x310, geno_matrix, trait = "Delta_CT_adj_Res", 15, .6)
# H_2023_310_ct <- stats_2023_310_ct$H[1]
#
# stats_2023_312_ct <- refine_heritability(Residual_Data_23_outliars_rm_314x312, geno_matrix, trait = "Delta_CT_adj_Res")
# H_2023_312_ct <- stats_2023_312_ct$H[1]
#
# stats_2023_star_ct <- refine_heritability(Residual_Data_23_outliars_rm, geno_matrix, trait = "Delta_CT_adj_Res", 15, .60)
# H_2023_star_ct <- stats_2023_star_ct$H[1]
#
# # Just the 2024 Heritabilities
# stats_2024_310_alk <- refine_heritability(Residual_Data_24_outliars_rm_314x310, geno_matrix, trait = "Alkaloids_Res", 15, .60)
# H_2024_310_alk <- stats_2024_310_alk$H[1]
#
# stats_2024_312_alk <- refine_heritability(Residual_Data_24_outliars_rm_314x312, geno_matrix, trait = "Alkaloids_Res", 20, .60)
# H_2024_312_alk <- stats_2024_312_alk$H[1]
#
# stats_2024_star_alk <- refine_heritability(Residual_Data_24_outliars_rm, geno_matrix, trait = "Alkaloids_Res", 20, .60)
# H_2024_star_alk <- stats_2024_star_alk$H[1]
#
# stats_2024_310_ct <- refine_heritability(Residual_Data_24_outliars_rm_314x310, geno_matrix, trait = "Delta_CT_adj_Res", 5, .60)
# H_2024_310_ct <- stats_2024_310_ct$H[1]
#
# stats_2024_312_ct <- refine_heritability(Residual_Data_24_outliars_rm_314x312, geno_matrix, trait = "Delta_CT_adj_Res")
# H_2024_312_ct <- stats_2024_312_ct$H[1]
#
# stats_2024_star_ct <- refine_heritability(Residual_Data_24_outliars_rm, geno_matrix, trait = "Delta_CT_adj_Res")
# H_2024_star_ct <- stats_2024_star_ct$H[1]
########## Plotting Heritability platoe ################
plot_avg_310_alk <- graph_heritability(Residual_data_avg_outliars_rm_314x310, geno_matrix, trait = "Alkaloids_Res", nrow(Residual_data_avg_outliars_rm_314x310)/2, .04)
# Ensure both datasets have the same IDs
common_IDs <- intersect(pheno_data$ID, rownames(geno_matrix))
################# Genetic relatedness matrix ###################################
pheno_data <- Residual_Data_23_outliars_rm_314x310
# Ensure both datasets have the same IDs
common_IDs <- intersect(pheno_data$ID, rownames(geno_matrix))
# Subset data to include only common IDs
pheno_data <- pheno_data[pheno_data$ID %in% common_IDs, ]
geno_matrix <- geno_matrix[common_IDs, ]
# Check if row names match
if (!all(rownames(geno_matrix) == pheno_data$ID)) {
stop("Row names of geno_data do not match the ID in pheno_data.")
}
# Convert geno_matrix to data frame, and then convert genotypes
geno_data <- as.data.frame(geno_matrix)
geno_data <- geno_data %>% mutate_all(convert_genotypes)
# Convert geno_data back to matrix for kinship matrix calculation
geno_data <- as.matrix(geno_data)
# Create kinship matrix using Gmatrix function
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
kinship_matrix
################# Genetic relatedness matrix ###################################
library(pheatmap)
install.packages(pheatmap)
install.packages("pheatmap")
################# Genetic relatedness matrix ###################################
library(pheatmap)
pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Kinship Matrix Heatmap")
pheno_data <- Residual_Data_24_outliars_rm_314x310
# Load the VCF file
vcf_data_loc <- "/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/VCF/all_snps_filtered_2.recode.vcf"
vcf_data <- read.vcfR(vcf_data_loc)
geno_matrix <- extract.gt(vcf_data, element = "GT")
geno_matrix <- t(geno_matrix)
# Ensure both datasets have the same IDs
common_IDs <- intersect(pheno_data$ID, rownames(geno_matrix))
# Subset data to include only common IDs
pheno_data <- pheno_data[pheno_data$ID %in% common_IDs, ]
geno_matrix <- geno_matrix[common_IDs, ]
# Check if row names match
if (!all(rownames(geno_matrix) == pheno_data$ID)) {
stop("Row names of geno_data do not match the ID in pheno_data.")
}
# Convert geno_matrix to data frame, and then convert genotypes
geno_data <- as.data.frame(geno_matrix)
geno_data <- geno_data %>% mutate_all(convert_genotypes)
# Convert geno_data back to matrix for kinship matrix calculation
geno_data <- as.matrix(geno_data)
# Create kinship matrix using Gmatrix function
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Kinship Matrix Heatmap")
pheno_data <- Residual_Data_23_outliars_rm
# Load the VCF file
vcf_data_loc <- "/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/VCF/all_snps_filtered_2.recode.vcf"
vcf_data <- read.vcfR(vcf_data_loc)
geno_matrix <- extract.gt(vcf_data, element = "GT")
geno_matrix <- t(geno_matrix)
# Ensure both datasets have the same IDs
common_IDs <- intersect(pheno_data$ID, rownames(geno_matrix))
# Subset data to include only common IDs
pheno_data <- pheno_data[pheno_data$ID %in% common_IDs, ]
geno_matrix <- geno_matrix[common_IDs, ]
# Check if row names match
if (!all(rownames(geno_matrix) == pheno_data$ID)) {
stop("Row names of geno_data do not match the ID in pheno_data.")
}
# Convert geno_matrix to data frame, and then convert genotypes
geno_data <- as.data.frame(geno_matrix)
geno_data <- geno_data %>% mutate_all(convert_genotypes)
# Convert geno_data back to matrix for kinship matrix calculation
geno_data <- as.matrix(geno_data)
# Create kinship matrix using Gmatrix function
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Kinship Matrix Heatmap")
# Perform PCA on the kinship matrix (or SNP matrix if needed)
pca_result <- prcomp(kinship_matrix)
pca_scores <- pca_result$x  # Principal component scores
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pca_scores <- pca_result$x  # Principal component scores
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pca_df <- data.frame(PC1 = pca_scores[, 1], PC2 = pca_scores[, 2])
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = PC1), size = 3) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal() +
theme(legend.position = "none")  # Remove legend if it's not needed
pca_df
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(size = 3) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal() +
theme(legend.position = "none")  # Remove legend if it's not needed
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(size = 3, color = "blue", alpha = 0.2) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal() +
theme(legend.position = "none")  # Remove legend if it's not needed
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(size = 3, color = "blue", alpha = 0.3) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal() +
theme(legend.position = "none")  # Remove legend if it's not needed
diag(kinship_matrix) <- NA
pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = "Kinship Matrix Heatmap")
# Load in Cross Identifier file
cross_list_loc <- paste0(base_path, "Data/Lists/Parent_Progeny_Lists/314_Star_Cross_Parents.txt")
################################################################################
# Calculating heritability
################################################################################
base_path <- "/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/"
# Load in Cross Identifier file
cross_list_loc <- paste0(base_path, "Data/Lists/Parent_Progeny_Lists/314_Star_Cross_Parents.txt")
cross_list <- read.table(cross_list_loc, header = FALSE)
cross_list
pca_df
View(cross_list)
View(pca_df)
pca_df <-merge(pca_df, cross_list, by.x = "V1", by.y = "row.names" )
pca_df <-merge(pca_df, cross_list, by.x = "row.names", by.y = "V1" )
pca_df
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(size = 3, color = V2, alpha = 0.3) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal() +
theme(legend.position = "none")  # Remove legend if it's not needed
head(pca_df)
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2) size = 3, alpha = 0.3) +
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal() +
theme(legend.position = "none")  # Remove legend if it's not needed
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal()
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +  # Plot the points
geom_text(
data = subset(pca_df, grepl("parent", V2, ignore.case = TRUE)),  # Filter for "parent"
aes(label = Row.names),
vjust = -1,  # Adjust text position
size = 3,
color = "black"
) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal()
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +  # Plot the points
geom_text(
data = subset(pca_df, grepl("parent", V2, ignore.case = TRUE)),  # Filter for "parent"
aes(label = Row.names),
vjust = -1,  # Adjust text position
size = 3,
color = "black"
) +
labs(title = "PCA: PC1 vs PC2", x = "PC1", y = "PC2") +
theme_minimal()
base_kin_analysis <- function(pheno_data, geno_matrix, title) {
# Ensure both datasets have the same IDs
common_IDs <- intersect(pheno_data$ID, rownames(geno_matrix))
# Subset data to include only common IDs
pheno_data <- pheno_data[pheno_data$ID %in% common_IDs, ]
geno_matrix <- geno_matrix[common_IDs, ]
# Check if row names match
if (!all(rownames(geno_matrix) == pheno_data$ID)) {
stop("Row names of geno_data do not match the ID in pheno_data.")
}
# Convert geno_matrix to data frame, and then convert genotypes
geno_data <- as.data.frame(geno_matrix)
geno_data <- geno_data %>% mutate_all(convert_genotypes)
# Convert geno_data back to matrix for kinship matrix calculation
geno_data <- as.matrix(geno_data)
# Create kinship matrix using Gmatrix function
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
diag(kinship_matrix) <- NA
kin_heatmap <- pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap", title))
# Perform PCA on the kinship matrix (or SNP matrix if needed)
pca_result <- prcomp(kinship_matrix)
pca_scores <- pca_result$x  # Principal component scores
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pca_df <- data.frame(PC1 = pca_scores[, 1], PC2 = pca_scores[, 2])
pca_df <-merge(pca_df, cross_list, by.x = "row.names", by.y = "V1" )
# Create the scatter plot of PC1 vs PC2
kin_pca <- ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +  # Plot the points
geom_text(
data = subset(pca_df, grepl("parent", V2, ignore.case = TRUE)),  # Filter for "parent"
aes(label = Row.names),
vjust = -1,  # Adjust text position
size = 3,
color = "black"
) +
labs(title = paste0("PCA:", title), x = "PC1", y = "PC2") +
theme_minimal()
return(list(plot1 = kin_heatmap, plot2 = kin_pca))
}
star_23_plots <- base_kin_analysis(Residual_Data_23_outliars_rm, geno_matrix, title = "Star Cross 2023")
base_path <- "/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/"
# Load in all 9 datasets
Residual_data_avg_outliars_rm_314x310 <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_data_avg_outliars_rm_314x310.txt", header = TRUE)
Residual_data_avg_outliars_rm_314x312 <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_data_avg_outliars_rm_314x312.txt", header = TRUE)
Residual_data_avg_outliars_rm <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_data_avg_outliars_rm.txt", header = TRUE)
Residual_Data_23_outliars_rm_314x310 <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_Data_23_outliars_rm_314x310.txt", header = TRUE)
Residual_Data_23_outliars_rm_314x312 <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_Data_23_outliars_rm_314x312.txt", header = TRUE)
Residual_Data_23_outliars_rm <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_Data_23_outliars_rm.txt", header = TRUE)
Residual_Data_24_outliars_rm_314x310 <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_Data_24_outliars_rm_314x310.txt", header = TRUE)
Residual_Data_24_outliars_rm_314x312 <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_Data_24_outliars_rm_314x312.txt", header = TRUE)
Residual_Data_24_outliars_rm <- read.table("/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/Phenotype_Data/Residual_Data/Residual_Data_24_outliars_rm.txt", header = TRUE)
# Load the VCF file
vcf_data_loc <- "/home/darrian/Desktop/UGA/Wallace_Lab/Mapping_and_QTL/Data/VCF/all_snps_filtered_2.recode.vcf"
vcf_data <- read.vcfR(vcf_data_loc)
geno_matrix <- extract.gt(vcf_data, element = "GT")
geno_matrix <- t(geno_matrix)
# Load in Cross Identifier file
cross_list_loc <- paste0(base_path, "Data/Lists/Parent_Progeny_Lists/314_Star_Cross_Parents.txt")
cross_list <- read.table(cross_list_loc, header = FALSE)
star_23_plots <- base_kin_analysis(Residual_Data_23_outliars_rm, geno_matrix, title = "Star Cross 2023")
common_IDs <- intersect(pheno_data$ID, rownames(geno_matrix))
# Subset data to include only common IDs
pheno_data <- pheno_data[pheno_data$ID %in% common_IDs, ]
geno_matrix <- geno_matrix[common_IDs, ]
# Check if row names match
if (!all(rownames(geno_matrix) == pheno_data$ID)) {
stop("Row names of geno_data do not match the ID in pheno_data.")
}
# Convert geno_matrix to data frame, and then convert genotypes
geno_data <- as.data.frame(geno_matrix)
geno_data <- geno_data %>% mutate_all(convert_genotypes)
# Convert geno_data back to matrix for kinship matrix calculation
geno_data <- as.matrix(geno_data)
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
diag(kinship_matrix) <- NA
kin_heatmap <- pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap", title))
title <- "LOOPS LOL"
kin_heatmap <- pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap", title))
# Perform PCA on the kinship matrix (or SNP matrix if needed)
pca_result <- prcomp(kinship_matrix)
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
pca_result <- prcomp(kinship_matrix)
diag(kinship_matrix) <- NA
kin_heatmap <- pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap ", title))
pca_scores <- pca_result$x  # Principal component scores
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pca_df <- data.frame(PC1 = pca_scores[, 1], PC2 = pca_scores[, 2])
pca_df <-merge(pca_df, cross_list, by.x = "row.names", by.y = "V1" )
# Create the scatter plot of PC1 vs PC2
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +  # Plot the points
geom_text(
data = subset(pca_df, grepl("parent", V2, ignore.case = TRUE)),  # Filter for "parent"
aes(label = Row.names),
vjust = -1,  # Adjust text position
size = 3,
color = "black"
) +
labs(title = paste0("PCA:", title), x = "PC1", y = "PC2") +
theme_minimal()
base_kin_analysis <- function(pheno_data, geno_matrix, title) {
# Ensure both datasets have the same IDs
common_IDs <- intersect(pheno_data$ID, rownames(geno_matrix))
# Subset data to include only common IDs
pheno_data <- pheno_data[pheno_data$ID %in% common_IDs, ]
geno_matrix <- geno_matrix[common_IDs, ]
# Check if row names match
if (!all(rownames(geno_matrix) == pheno_data$ID)) {
stop("Row names of geno_data do not match the ID in pheno_data.")
}
# Convert geno_matrix to data frame, and then convert genotypes
geno_data <- as.data.frame(geno_matrix)
geno_data <- geno_data %>% mutate_all(convert_genotypes)
# Convert geno_data back to matrix for kinship matrix calculation
geno_data <- as.matrix(geno_data)
# Create kinship matrix using Gmatrix function
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
pca_result <- prcomp(kinship_matrix)
diag(kinship_matrix) <- NA
kin_heatmap <- pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap ", title))
# Perform PCA on the kinship matrix (or SNP matrix if needed)
pca_scores <- pca_result$x  # Principal component scores
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pca_df <- data.frame(PC1 = pca_scores[, 1], PC2 = pca_scores[, 2])
pca_df <-merge(pca_df, cross_list, by.x = "row.names", by.y = "V1" )
# Create the scatter plot of PC1 vs PC2
kin_pca <- ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +  # Plot the points
geom_text(
data = subset(pca_df, grepl("parent", V2, ignore.case = TRUE)),  # Filter for "parent"
aes(label = Row.names),
vjust = -1,  # Adjust text position
size = 3,
color = "black"
) +
labs(title = paste0("PCA:", title), x = "PC1", y = "PC2") +
theme_minimal()
return(list(plot1 = kin_heatmap, plot2 = kin_pca))
}
star_23_plots <- base_kin_analysis(Residual_Data_23_outliars_rm, geno_matrix, title = "Star Cross 2023")
star_23_plots$plot1
star_23_plots$plot2
plots_314x310_23 <- base_kin_analysis(Residual_Data_23_outliars_rm_314x310, geno_matrix, cross_list, title = "314x310 2023")
base_kin_analysis <- function(pheno_data, geno_matrix, cross_list, title) {
# Ensure both datasets have the same IDs
common_IDs <- intersect(pheno_data$ID, rownames(geno_matrix))
# Subset data to include only common IDs
pheno_data <- pheno_data[pheno_data$ID %in% common_IDs, ]
geno_matrix <- geno_matrix[common_IDs, ]
# Check if row names match
if (!all(rownames(geno_matrix) == pheno_data$ID)) {
stop("Row names of geno_data do not match the ID in pheno_data.")
}
# Convert geno_matrix to data frame, and then convert genotypes
geno_data <- as.data.frame(geno_matrix)
geno_data <- geno_data %>% mutate_all(convert_genotypes)
# Convert geno_data back to matrix for kinship matrix calculation
geno_data <- as.matrix(geno_data)
# Create kinship matrix using Gmatrix function
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
pca_result <- prcomp(kinship_matrix)
diag(kinship_matrix) <- NA
kin_heatmap <- pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap ", title))
# Perform PCA on the kinship matrix (or SNP matrix if needed)
pca_scores <- pca_result$x  # Principal component scores
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pca_df <- data.frame(PC1 = pca_scores[, 1], PC2 = pca_scores[, 2])
pca_df <-merge(pca_df, cross_list, by.x = "row.names", by.y = "V1" )
# Create the scatter plot of PC1 vs PC2
kin_pca <- ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +  # Plot the points
geom_text(
data = subset(pca_df, grepl("parent", V2, ignore.case = TRUE)),  # Filter for "parent"
aes(label = Row.names),
vjust = -1,  # Adjust text position
size = 3,
color = "black"
) +
labs(title = paste0("PCA:", title), x = "PC1", y = "PC2") +
theme_minimal()
return(list(plot1 = kin_heatmap, plot2 = kin_pca))
}
plots_314x310_23 <- base_kin_analysis(Residual_Data_23_outliars_rm_314x310, geno_matrix, cross_list, title = "314x310 2023")
plots_314x310_23$plot1
plots_314x310_23$plot2
plots_star_23 <- base_kin_analysis(Residual_Data_23_outliars_rm, geno_matrix, cross_list, title = "Star Cross 2023")
plots_star_23$plot1
Residual_Data_23_outliars_rm
geno_matrix
cross_list
plots_star_23 <- base_kin_analysis(Residual_Data_23_outliars_rm, geno_matrix, cross_list, title = "Star Cross 2023")
plots_star_23
plots_star_23$plot1
pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap ", title))
View(kinship_matrix)
kinship_matrix <- Gmatrix(SNPmatrix = geno_data, method = "VanRaden")
pca_result <- prcomp(kinship_matrix)
diag(kinship_matrix) <- NA
pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap ", title))
pheatmap(kinship_matrix,
cluster_rows = TRUE,
cluster_cols = TRUE,
color = colorRampPalette(c("blue", "white", "red"))(50),
main = paste0("Kinship Matrix Heatmap ", title))
pca_scores <- pca_result$x  # Principal component scores
explained_variance <- pca_result$sdev^2 / sum(pca_result$sdev^2)
pca_df <- data.frame(PC1 = pca_scores[, 1], PC2 = pca_scores[, 2])
pca_df <-merge(pca_df, cross_list, by.x = "row.names", by.y = "V1" )
ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +  # Plot the points
geom_text(
data = subset(pca_df, grepl("parent", V2, ignore.case = TRUE)),  # Filter for "parent"
aes(label = Row.names),
vjust = -1,  # Adjust text position
size = 3,
color = "black"
) +
labs(title = paste0("PCA:", title), x = "PC1", y = "PC2") +
theme_minimal()
pca_df
kin_pca <- ggplot(pca_df, aes(x = PC1, y = PC2)) +
geom_point(aes(color = V2), size = 3, alpha = 0.3) +  # Plot the points
geom_text(
data = subset(pca_df, grepl("parent", V2, ignore.case = TRUE)),  # Filter for "parent"
aes(label = Row.names),
vjust = -1,  # Adjust text position
size = 3,
color = "black"
) +
labs(title = paste0("PCA:", title), x = "PC1", y = "PC2") +
theme_minimal()
View(kin_pca)
kin_pca
